        -:    0:Source:replace25.c
        -:    0:Graph:replace25.gcno
        -:    0:Data:replace25.gcda
        -:    0:Runs:55
        -:    0:Programs:1
        -:    1:/*  -*- Last-Edit:  Mon Dec  7 10:31:51 1992 by Tarak S. Goradia; -*- */
        -:    2:
        -:    3:extern void	exit();
        -:    4:# include <stdio.h>
        -:    5:
        -:    6:void	Caseerror();
        -:    7:
        -:    8:typedef char	bool;
        -:    9:# define false 0
        -:   10:# define true  1
        -:   11:# define NULL 0
        -:   12:
        -:   13:# define MAXSTR 100
        -:   14:# define MAXPAT MAXSTR
        -:   15:
        -:   16:# define ENDSTR  '\0'
        -:   17:# define ESCAPE  '@'
        -:   18:# define CLOSURE '*'
        -:   19:# define BOL     '%'
        -:   20:# define EOL     '$'
        -:   21:# define ANY     '?'
        -:   22:# define CCL     '['
        -:   23:# define CCLEND  ']'
        -:   24:# define NEGATE  '^'
        -:   25:# define NCCL    '!'
        -:   26:# define LITCHAR 'c'
        -:   27:# define DITTO   -1
        -:   28:# define DASH    '-'
        -:   29:
        -:   30:# define TAB     9
        -:   31:# define NEWLINE 10
        -:   32:
        -:   33:# define CLOSIZE 1
        -:   34:
        -:   35:typedef char	character;
        -:   36:typedef char string[MAXSTR];
        -:   37:
        -:   38:int
function addstr called 340 returned 100% blocks executed 75%
      340:   39:addstr(c, outset, j, maxset)
        -:   40:char	c;
        -:   41:char	*outset;
        -:   42:int	*j;
        -:   43:int	maxset;
        -:   44:{
        -:   45:    bool	result;
      340:   46:    if (*j >= maxset)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   47:	result = false;
        -:   48:    else {
      340:   49:	outset[*j] = c;
      340:   50:	*j = *j + 1;
      340:   51:	result = true;
        -:   52:    }
      340:   53:    return result;
        -:   54:}
        -:   55:
        -:   56:char
function esc called 42 returned 100% blocks executed 100%
       42:   57:esc(s, i)
        -:   58:char 	*s;
        -:   59:int	*i;
        -:   60:{
        -:   61:    char	result;
       42:   62:    if (s[*i] != ESCAPE)
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
       26:   63:	result = s[*i];
        -:   64:    else
       16:   65:	if (s[*i + 1] == ENDSTR)
branch  0 taken 31% (fallthrough)
branch  1 taken 69%
        5:   66:	    result = ESCAPE;
        -:   67:	else 
        -:   68:	{
       11:   69:	    *i = *i + 1;
       11:   70:	    if (s[*i] == 'n')
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
        5:   71:		result = NEWLINE;
        -:   72:	    else
        6:   73:		if (s[*i] == 't')
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        3:   74:		    result = TAB;
        -:   75:		else
        3:   76:		    result = s[*i];
        -:   77:	}
       42:   78:    return result;
        -:   79:}
        -:   80:
        -:   81:char * change();
        -:   82:
        -:   83: void
function dodash called 25 returned 100% blocks executed 77%
       25:   84:dodash(delim, src, i, dest, j, maxset)
        -:   85:char	delim;
        -:   86:char	*src;
        -:   87:int	*i;
        -:   88:char	*dest;
        -:   89:int	*j;
        -:   90:int	maxset;
        -:   91:{
        -:   92:    int	k;
        -:   93:    bool	junk;
        -:   94:    char	escjunk;
        -:   95:
       97:   96:    while ((src[*i] != delim) && (src[*i] != ENDSTR)) 
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
branch  2 taken 82%
branch  3 taken 18% (fallthrough)
        -:   97:    {
       47:   98:	if (src[*i - 1] == ESCAPE) {
branch  0 taken 19% (fallthrough)
branch  1 taken 81%
        9:   99:	    escjunk = esc(src, i);
call    0 returned 100%
        9:  100:	    junk = addstr(escjunk, dest, j, maxset);
call    0 returned 100%
        -:  101:	} else	
       38:  102:	    if (src[*i] != DASH)
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
       30:  103:		junk = addstr(src[*i], dest, j, maxset);
call    0 returned 100%
       13:  104:	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 63% (fallthrough)
branch  3 taken 38%
        5:  105:		junk = addstr(DASH, dest, j, maxset);
call    0 returned 100%
        3:  106:	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1])) 
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
    #####:  107:		&& (src[*i - 1] <= src[*i + 1]))
        -:  108:		{
    #####:  109:		    for (k = src[*i-1]+1; k<=src[*i+1]; k++) 
branch  0 never executed
branch  1 never executed
        -:  110:		    {
    #####:  111:			junk = addstr(k, dest, j, maxset);
call    0 never executed
        -:  112:		    }	
    #####:  113:		    *i = *i + 1;	
        -:  114:		} 
        -:  115:	    else	
        3:  116:		junk = addstr(DASH, dest, j, maxset);
call    0 returned 100%
       47:  117:	(*i) = (*i) + 1;
        -:  118:    }
       25:  119:}
        -:  120:
        -:  121:bool
function getccl called 25 returned 100% blocks executed 100%
       25:  122:getccl(arg, i, pat, j)
        -:  123:char	*arg;
        -:  124:int	*i;
        -:  125:char	*pat;
        -:  126:int	*j;
        -:  127:{
        -:  128:    int	jstart;
        -:  129:    bool	junk;
        -:  130:
       25:  131:    *i = *i + 1;
       25:  132:    if (arg[*i] == NEGATE) {
branch  0 taken 44% (fallthrough)
branch  1 taken 56%
       11:  133:	junk = addstr(NCCL, pat, j, MAXPAT);
call    0 returned 100%
       11:  134:	*i = *i + 1;
        -:  135:    } else
       14:  136:	junk = addstr(CCL, pat, j, MAXPAT);
call    0 returned 100%
       25:  137:    jstart = *j;
       25:  138:    junk = addstr(0, pat, j, MAXPAT);
call    0 returned 100%
       25:  139:    dodash(CCLEND, arg, i, pat, j, MAXPAT);
call    0 returned 100%
       25:  140:    pat[jstart] = *j - jstart - 1;
       25:  141:    return (arg[*i] == CCLEND);
        -:  142:}
        -:  143:
        -:  144: void
function stclose called 5 returned 100% blocks executed 100%
        5:  145:stclose(pat, j, lastj)
        -:  146:char	*pat;
        -:  147:int	*j;
        -:  148:int	lastj;
        -:  149:{
        -:  150:    int	jt;
        -:  151:    int	jp;
        -:  152:    bool	junk;
        -:  153:
        -:  154:
       12:  155:    for (jp = *j - 1; jp >= lastj ; jp--) 
branch  0 taken 58%
branch  1 taken 42% (fallthrough)
        -:  156:    {
        7:  157:	jt = jp + CLOSIZE;
        7:  158:	junk = addstr(pat[jp], pat, &jt, MAXPAT);
call    0 returned 100%
        -:  159:    }
        5:  160:    *j = *j + CLOSIZE;
        5:  161:    pat[lastj] = CLOSURE;
        5:  162:}
        -:  163:
function in_set_2 called 6 returned 100% blocks executed 100%
        6:  164:bool in_set_2(c)
        -:  165:char c;
        -:  166:{
        6:  167:  return (c == BOL || c == EOL || c == CLOSURE);
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -:  168:}      
        -:  169:
function in_pat_set called 292 returned 100% blocks executed 90%
      292:  170:bool in_pat_set(c)
        -:  171:char c;
        -:  172:{
      292:  173:  return (   c == LITCHAR || c == BOL  || c == EOL || c == ANY 
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
branch  2 taken 89% (fallthrough)
branch  3 taken 11%
branch  4 taken 97% (fallthrough)
branch  5 taken 3%
branch  6 taken 57% (fallthrough)
branch  7 taken 43%
branch  8 taken 46% (fallthrough)
branch  9 taken 54%
branch 10 taken 14% (fallthrough)
branch 11 taken 86%
branch 12 taken 100% (fallthrough)
branch 13 taken 0%
        -:  174:          || c == CCL     || c == NCCL || c == CLOSURE);
        -:  175:}      
        -:  176:
        -:  177:int
function makepat called 55 returned 100% blocks executed 97%
       55:  178:makepat(arg, start, delim, pat)
        -:  179:char	*arg;
        -:  180:int	start;
        -:  181:char	delim;
        -:  182:char	*pat;
        -:  183:{
        -:  184:    int	result;
        -:  185:    int	i, j, lastj, lj;
        -:  186:    bool	done, junk;
        -:  187:    bool	getres;
        -:  188:    char	escjunk;
        -:  189:
       55:  190:    j = 0;
       55:  191:    i = start;
       55:  192:    lastj = 0;
       55:  193:    done = false;
      184:  194:    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
branch  2 taken 63% (fallthrough)
branch  3 taken 37%
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
       74:  195:	lj = j;
       74:  196:	if ((arg[i] == ANY))
branch  0 taken 26% (fallthrough)
branch  1 taken 74%
       19:  197:	    junk = addstr(ANY, pat, &j, MAXPAT);
call    0 returned 100%
       60:  198:	else if ((arg[i] == BOL) && (i == start))
branch  0 taken 9% (fallthrough)
branch  1 taken 91%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        5:  199:	    junk = addstr(BOL, pat, &j, MAXPAT);
call    0 returned 100%
       52:  200:	else if ((arg[i] == EOL) && (arg[i+1] == delim))
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
        2:  201:	    junk = addstr(EOL, pat, &j, MAXPAT);
call    0 returned 100%
       48:  202:	else if ((arg[i] == CCL)) 
branch  0 taken 52% (fallthrough)
branch  1 taken 48%
        -:  203:	{
       25:  204:	    getres = getccl(arg, &i, pat, &j);
call    0 returned 100%
       25:  205:	    done = (bool)(getres == false);
        -:  206:	} 
       29:  207:	else if ((arg[i] == CLOSURE) && (i > start)) 
branch  0 taken 26% (fallthrough)
branch  1 taken 74%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  208:	{
        6:  209:	    lj = lastj;
        6:  210:	    if (in_set_2(pat[lj]))
call    0 returned 100%
branch  1 taken 17% (fallthrough)
branch  2 taken 83%
        1:  211:		done = true;
        -:  212:	    else
        5:  213:		stclose(pat, &j, lastj);
call    0 returned 100%
        -:  214:	} 
        -:  215:	else 
        -:  216:	{
       17:  217:	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
call    0 returned 100%
       17:  218:	    escjunk = esc(arg, &i);
call    0 returned 100%
       17:  219:	    junk = addstr(escjunk, pat, &j, MAXPAT);
call    0 returned 100%
        -:  220:	}
       74:  221:	lastj = lj;
       74:  222:	if ((!done))
branch  0 taken 85% (fallthrough)
branch  1 taken 15%
       63:  223:	    i = i + 1;
        -:  224:    }	
       55:  225:    junk = addstr(ENDSTR, pat, &j, MAXPAT);
call    0 returned 100%
       66:  226:    if ((done) || (arg[i] != delim))
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
       11:  227:	result = 0;
        -:  228:    else
       44:  229:	if ((!junk))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  230:	    result = 0;
        -:  231:	else
       44:  232:	    result = i;
       55:  233:    return result;
        -:  234:}
        -:  235:
        -:  236:int
function getpat called 55 returned 100% blocks executed 100%
       55:  237:getpat(arg, pat)
        -:  238:char*	arg;
        -:  239:char*	pat;
        -:  240:{
        -:  241:    int	makeres;
        -:  242:
       55:  243:    makeres = makepat(arg, 0, ENDSTR, pat);
call    0 returned 100%
       55:  244:    return (makeres > 0);
        -:  245:}
        -:  246:
        -:  247:int
function makesub called 55 returned 100% blocks executed 88%
       55:  248:makesub(arg, from, delim, sub)
        -:  249:	char*	arg;
        -:  250:	int	from;
        -:  251:	character	delim;
        -:  252:	char*	sub;
        -:  253:{
        -:  254:    int  result;
        -:  255:    int	i, j;
        -:  256:    bool	junk;
        -:  257:    character	escjunk;
        -:  258:
       55:  259:    j = 0;
       55:  260:    i = from;
      176:  261:    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
branch  0 taken 55% (fallthrough)
branch  1 taken 45%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
       66:  262:	if ((arg[i] == (unsigned)('&')))
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
       50:  263:	    junk = addstr(DITTO, sub, &j, MAXPAT);
call    0 returned 100%
        -:  264:	else {
       16:  265:	    escjunk = esc(arg, &i);
call    0 returned 100%
       16:  266:	    junk = addstr(escjunk, sub, &j, MAXPAT);
call    0 returned 100%
        -:  267:	}
       66:  268:	i = i + 1;
        -:  269:    }
       55:  270:    if (arg[i] != delim)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  271:	result = 0;
        -:  272:    else {
       55:  273:	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
call    0 returned 100%
       55:  274:	if ((!junk))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  275:	    result = 0;
        -:  276:	else
       55:  277:	    result = i;
        -:  278:    }	
       55:  279:    return result;
        -:  280:}
        -:  281:
        -:  282:bool
function getsub called 55 returned 100% blocks executed 100%
       55:  283:getsub(arg, sub)
        -:  284:	char*	arg;
        -:  285:	char*	sub;
        -:  286:{
        -:  287:    int	makeres;
        -:  288:
       55:  289:    makeres = makesub(arg, 0, ENDSTR, sub);
call    0 returned 100%
       55:  290:    return (makeres > 0);
        -:  291:}
        -:  292:
        -:  293:char * subline();
        -:  294:
        -:  295: bool
function locate called 74 returned 100% blocks executed 100%
       74:  296:locate(c, pat, offset)
        -:  297:	character	c;
        -:  298:	char *	pat;
        -:  299:	int	offset;
        -:  300:{
        -:  301:    int	i;
        -:  302:    bool flag;
        -:  303:
       74:  304:    flag = false;
       74:  305:    i = offset + pat[offset];
      268:  306:    while ((i > offset))
branch  0 taken 62%
branch  1 taken 38% (fallthrough)
        -:  307:    {
      120:  308:	if (c == pat[i]) {
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
       20:  309:	    flag = true;
       20:  310:	    i = offset;
        -:  311:	} else
      100:  312:	    i = i - 1;
        -:  313:    }
       74:  314:    return flag;
        -:  315:}
        -:  316:
        -:  317:bool
function omatch called 178 returned 100% blocks executed 89%
      178:  318:omatch(lin, i, pat, j)
        -:  319:	char*	lin;
        -:  320:	int	*i;
        -:  321:	char*	pat;
        -:  322:	int	j;
        -:  323:{
        -:  324:    char	advance;
        -:  325:    bool result;
        -:  326:    
      178:  327:    advance = -1;
      178:  328:    if ((lin[*i] == ENDSTR))
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        2:  329:	result = false;
        -:  330:    else 
        -:  331:    {
      176:  332:	if (!in_pat_set(pat[j]))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  333:	{
    #####:  334:	    (void)fprintf(stdout, "in omatch: can't happen\n");
call    0 never executed
    #####:  335:	    abort();	
call    0 never executed
        -:  336:	} else
        -:  337:	{
        -:  338:	     //switch (pat[j]) 
        -:  339:	     //{			
      176:  340:	     if(pat[j]== LITCHAR){
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
       21:  341:		 if (lin[*i] == pat[j + 1])
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
       13:  342:		     advance = 1;
        -:  343:		}	
      155:  344:	     else if(pat[j]== BOL){
branch  0 taken 15% (fallthrough)
branch  1 taken 85%
       24:  345:		 if (*i == 0)
branch  0 taken 21% (fallthrough)
branch  1 taken 79%
        5:  346:		     advance = 0;
        -:  347:		 }
      131:  348:	     else if(pat[j]== ANY){
branch  0 taken 37% (fallthrough)
branch  1 taken 63%
       49:  349:		 if (lin[*i] != NEWLINE)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       49:  350:		     advance = 1;
        -:  351:		 }
       82:  352:	     else if(pat[j]== EOL){
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
        8:  353:		 if (lin[*i] <= NEWLINE)//fault ==
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  354:		     advance = 0;
        -:  355:		 }
       74:  356:	     else if(pat[j]== CCL){
branch  0 taken 64% (fallthrough)
branch  1 taken 36%
       47:  357:		 if (locate(lin[*i], pat, j + 1))
call    0 returned 100%
branch  1 taken 36% (fallthrough)
branch  2 taken 64%
       17:  358:		     advance = 1;	
        -:  359:		 }
       27:  360:	     else if(pat[j]== NCCL){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       27:  361:		 if ((lin[*i] != NEWLINE) && (!locate(lin[*i], pat, j+1)))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 89% (fallthrough)
branch  4 taken 11%
       24:  362:		     advance = 1;	
        -:  363:		 }
        -:  364:	     else
    #####:  365:		 Caseerror(pat[j]);
call    0 never executed
        -:  366:	 }	
        -:  367:    }
      178:  368:    if ((advance >= 0)) 
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
        -:  369:    {
      108:  370:	*i = *i + advance;
      108:  371:	result = true;
        -:  372:    } else
       70:  373:	result = false;
      178:  374:    return result;
        -:  375:}
        -:  376:
        -:  377:
function patsize called 116 returned 100% blocks executed 73%
      116:  378:patsize(pat, n)
        -:  379:	char*	pat;
        -:  380:	int	n;
        -:  381:{
        -:  382:    int size;
      116:  383:    if (!in_pat_set(pat[n])) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  384:	(void)fprintf(stdout, "in patsize: can't happen\n");
call    0 never executed
    #####:  385:	abort();
call    0 never executed
        -:  386:    } else
      116:  387:	switch (pat[n]) 
branch  0 taken 11%
branch  1 taken 43%
branch  2 taken 39%
branch  3 taken 7%
branch  4 taken 0%
        -:  388:	{
       13:  389:	case LITCHAR: size = 2; break;
        -:  390:	    
        -:  391:	case BOL:  case EOL:  case ANY:
       50:  392:	    size = 1;
       50:  393:	    break;
        -:  394:	case CCL:  case NCCL:
       45:  395:	    size = pat[n + 1] + 2;
       45:  396:	    break ;
        -:  397:	case CLOSURE:
        8:  398:	    size = CLOSIZE;
        8:  399:	    break ;
        -:  400:	default:
    #####:  401:	    Caseerror(pat[n]);
call    0 never executed
        -:  402:	}
      116:  403:    return size;
        -:  404:}
        -:  405:
        -:  406:int
function amatch called 165 returned 100% blocks executed 100%
      165:  407:amatch(lin, offset, pat, j)
        -:  408:	char*	lin;
        -:  409:	int	offset;
        -:  410:	char*	pat;
        -:  411:	int	j;
        -:  412:{
        -:  413:    int	i, k;
        -:  414:    bool	result, done;
        -:  415:
      165:  416:    done = false;
      503:  417:    while ((!done) && (pat[j] != ENDSTR))
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
branch  2 taken 66%
branch  3 taken 34% (fallthrough)
      173:  418:	if ((pat[j] == CLOSURE)) {
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
        8:  419:	    j = j + patsize(pat, j);
call    0 returned 100%
        8:  420:	    i = offset;
       29:  421:	    while ((!done) && (lin[i] != ENDSTR)) {
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
branch  2 taken 76%
branch  3 taken 24% (fallthrough)
       13:  422:		result = omatch(lin, &i, pat, j);
call    0 returned 100%
       13:  423:		if (!result)	
branch  0 taken 31% (fallthrough)
branch  1 taken 69%
        4:  424:		    done = true;
        -:  425:	    }
        8:  426:	    done = false;
       25:  427:	    while ((!done) && (i >= offset)) {
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
        9:  428:		k = amatch(lin, i, pat, j + patsize(pat, j));
call    0 returned 100%
call    1 returned 100%
        9:  429:		if ((k >= 0))
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
        8:  430:		    done = true;
        -:  431:		else
        1:  432:		    i = i - 1;
        -:  433:	    }
        8:  434:	    offset = k;
        8:  435:	    done = true;
        -:  436:	} else {
      165:  437:	    result = omatch(lin, &offset, pat, j);
call    0 returned 100%
      165:  438:	    if ((!result)) {	
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
       66:  439:		offset = -1;
       66:  440:		done = true;
        -:  441:	    } else
       99:  442:		j = j + patsize(pat, j);
call    0 returned 100%
        -:  443:	}
      165:  444:     return offset;
        -:  445:}
        -:  446:
        -:  447:void
function putsub called 91 returned 100% blocks executed 100%
       91:  448:putsub(lin, s1, s2, sub,output,OL)
        -:  449:  char * lin;
        -:  450:  int	s1, s2;
        -:  451:  char * sub;
        -:  452:  char * output;
        -:  453:  int *OL;
        -:  454:{
        -:  455:    int	i;
        -:  456:    int		j;
        -:  457:
       91:  458:    i = 0;
      302:  459:    while ((sub[i] != ENDSTR)) {
branch  0 taken 57%
branch  1 taken 43% (fallthrough)
      120:  460:	if ((sub[i] == DITTO))
branch  0 taken 68% (fallthrough)
branch  1 taken 33%
      170:  461:	    for (j = s1; j < s2; j++) 
branch  0 taken 52%
branch  1 taken 48% (fallthrough)
        -:  462:	    {
        -:  463:		//fputc(lin[j],stdout);
       89:  464:                if((*OL)<2000){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       89:  465:                output[*OL]=lin[j];(*OL)++;
        -:  466:                }
        -:  467:	    }	
        -:  468:	else	
        -:  469:	{
        -:  470:	    //fputc(sub[i],stdout);
       39:  471:            if((*OL)<2000){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       39:  472:            output[*OL]=sub[i];(*OL)++;}
        -:  473:         }
      120:  474:	i = i + 1;
        -:  475:    }
       91:  476:}
        -:  477:
        -:  478:char *
function subline called 55 returned 100% blocks executed 94%
       55:  479:subline(lin, pat, sub)
        -:  480: char	*lin;
        -:  481: char   *pat;
        -:  482: char   *sub;
        -:  483:{	
        -:  484:	int	i, lastm, m;
        -:  485:        static char O[2000]="";
       55:  486:        int OL=0;
       55:  487:	lastm = -1;
       55:  488:	i = 0;
      266:  489:	while ((lin[i] != ENDSTR)) 
branch  0 taken 74%
branch  1 taken 26% (fallthrough)
        -:  490:	{
      156:  491:	    m = amatch(lin, i, pat, 0);
call    0 returned 100%
      156:  492:	    if ((m >= 0) && (lastm != m)) {
branch  0 taken 58% (fallthrough)
branch  1 taken 42%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       91:  493:		putsub(lin, i, m, sub,O,&OL);
call    0 returned 100%
       91:  494:		lastm = m;
        -:  495:	    }
      230:  496:	    if ((m == -1) || (m == i)) {
branch  0 taken 58% (fallthrough)
branch  1 taken 42%
branch  2 taken 10% (fallthrough)
branch  3 taken 90%
        -:  497:		//fputc(lin[i],stdout);
       74:  498:                if(OL<2000){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       74:  499:                O[OL]=lin[i];OL++;}
       74:  500:		i = i + 1;
        -:  501:	    } else
       82:  502:		i = m;
        -:  503:	}
       55:  504:      if(OL<2000)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       55:  505:        O[OL]='\0';
        -:  506:      else
    #####:  507:        O[OL-1]='\0';
       55:  508:       return O;
        -:  509:}
        -:  510:
        -:  511:
        -:  512: char *
function change called 55 returned 100% blocks executed 100%
       55:  513:change(pat, sub,line)
        -:  514:char *pat, *sub, *line;
        -:  515:{
       55:  516:  return subline(line, pat, sub);
call    0 returned 100%
        -:  517:}
function mainQ called 55 returned 100% blocks executed 100%
       55:  518:char *mainQ(char *argv1, char *argv2, char *argv3)
        -:  519:{
        -:  520:   string pat, sub;
        -:  521:   bool result;
       55:  522:   result = getpat(argv1, pat);
call    0 returned 100%
       55:  523:   result = getsub(argv2, sub);
call    0 returned 100%
       55:  524:   return change(pat,sub,argv3);
call    0 returned 100%
        -:  525:}
function main called 55 returned 100% blocks executed 100%
       55:  526:int main(int argc, char*argv[])
        -:  527:{
       55:  528:   fprintf(stdout,"%s\n",mainQ(argv[1],argv[2],argv[3]));
call    0 returned 100%
call    1 returned 100%
       55:  529:   return 0;
        -:  530:}
        -:  531:
        -:  532:void
function Caseerror called 0 returned 0% blocks executed 0%
    #####:  533:Caseerror(n)
        -:  534:	int	n;
        -:  535:{
    #####:  536:	(void)fprintf(stdout, "Missing case limb: line %d\n", n);
call    0 never executed
    #####:  537:	exit(4);
call    0 never executed
        -:  538:}
