        -:    0:Source:m1.c
        -:    0:Graph:m1.gcno
        -:    0:Data:m1.gcda
        -:    0:Runs:36
        -:    0:Programs:1
        -:    1:
        -:    2:/* $Log: schedule.c,v $
        -:    3: * Revision 1.4  1993/05/04  12:23:58  foster
        -:    4: * Debug stuff removed
        -:    5: *
        -:    6: * Revision 1.3  1993/05/03  20:27:04  foster
        -:    7: * Full Functionality
        -:    8: *
        -:    9: * Revision 1.2  1993/05/03  15:41:01  foster
        -:   10: * Restructure functions
        -:   11: *
        -:   12: * Revision 1.1  1993/05/01  11:38:04  foster
        -:   13: * Initial revision
        -:   14: * */
        -:   15:
        -:   16:#include <stdio.h>
        -:   17:#include "schedule2.h"
        -:   18:#include "processor.h"
        -:   19:
        -:   20:extern float getOperand(char * str);
        -:   21:
        -:   22:extern void getAdata(char * str,int *pos, char * s);
        -:   23:
        -:   24:static struct process * current_job;
        -:   25:static int next_pid = 0;
        -:   26:
        -:   27:int
function enqueue called 327 returned 100% blocks executed 100%
      327:   28:enqueue(prio, new_process)
        -:   29:     int prio;
        -:   30:     struct process *new_process;
        -:   31:{
        -:   32:    int status;
      327:   33:    if(status = put_end(prio, new_process)) return(status); /* Error */
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
      323:   34:    return(reschedule(prio));
call    0 returned 100%
        -:   35:}
        -:   36:
        -:   37:struct queue
        -:   38:{
        -:   39:    int length;
        -:   40:    struct process *head;
        -:   41:};
        -:   42:
        -:   43:static struct queue prio_queue[MAXPRIO + 1]; /* blocked queue is [0] */
        -:   44:
        -:   45:
        -:   46://-----------------------------------------------------------------
        -:   47:		
        -:   48:
function mainQ called 36 returned 100% blocks executed 83%
       36:   49:char *mainQ(char *argv) /* n3, n2, n1 : # of processes at prio3 ... */
        -:   50:{
        -:   51:    int command, prio;
        -:   52:    float ratio;
        -:   53:    int nprocs, status, pid;
        -:   54:    struct process *process;
        -:   55:    static char r[2000]=""; 
       36:   56:    char value[10]="";
        -:   57:    int a3,a2,a1;
       36:   58:    int pos=0;
        -:   59:    //--------------------------------------------------------------------
       36:   60:    getAdata(argv,&pos,value);
call    0 returned 100%
       36:   61:    a3=atoi(value);
call    0 returned 100%
       36:   62:    getAdata(argv,&pos,value);
call    0 returned 100%
       36:   63:    a2=atoi(value);
call    0 returned 100%
       36:   64:    getAdata(argv,&pos,value);
call    0 returned 100%
       36:   65:    a1=atoi(value);
call    0 returned 100%
        -:   66:
       36:   67:        prio=3;
       36:   68:	if(a3 < 0) exit_here(BADARG);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
      101:   69:	for(; a3 > 0; a3--)
branch  0 taken 64%
branch  1 taken 36% (fallthrough)
        -:   70:	{
       65:   71:	    if(status = new_job(prio)) exit_here(status);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:   72:	}
       36:   73:        prio=2;
       36:   74:	if(a2 < 0) exit_here(BADARG);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
      121:   75:	for(; a2 > 0; a2--)
branch  0 taken 70%
branch  1 taken 30% (fallthrough)
        -:   76:	{
       85:   77:	    if(status = new_job(prio)) exit_here(status);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:   78:	}
       36:   79:        prio=1;
       36:   80:	if(a1 < 0) exit_here(BADARG);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
      107:   81:	for(; a1 > 0; a1--)
branch  0 taken 66%
branch  1 taken 34% (fallthrough)
        -:   82:	{
       71:   83:	    if(status = new_job(prio)) exit_here(status);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:   84:	}
       36:   85:        while(argv[pos]!='\0' && argv[pos]!='\n'){ (pos)++;}
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
       36:   86:        if(argv[pos]=='\n') (pos)++;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   87:    //----------------------------------------------------------------
        -:   88:    /* while there are commands, schedule it */
      252:   89:    while((status = get_command(&command, &prio, &ratio,argv,&pos)) > 0)
call    0 returned 100%
branch  1 taken 83%
branch  2 taken 17% (fallthrough)
        -:   90:    {
      180:   91:	schedule(command, prio, ratio,r);
call    0 returned 100%
        -:   92:    }
        -:   93:
       36:   94:    return r;
        -:   95:    if(status < 0) {exit_here(status);} /* Real bad error */
        -:   96:    exit_here(OK);
        -:   97:
        -:   98:    
        -:   99:}
function main called 36 returned 100% blocks executed 100%
       36:  100:main(argc, argv)
        -:  101:int argc;
        -:  102:char *argv[];
        -:  103:{
       36:  104:      fprintf(stdout,"%s",mainQ(argv[1]));
call    0 returned 100%
call    1 returned 100%
       36:  105:}
        -:  106://--------------------------------------------------------------------------------
        -:  107:int 
function get_command called 216 returned 100% blocks executed 96%
      216:  108:get_command(int *command, int *prio, float *ratio,char *argv,int *pos)
        -:  109:{
      216:  110:    int status = OK;
      216:  111:    char value[10]="";
        -:  112:
        -:  113:    char buf[CMDSIZE];
        -:  114:    //if(fgets(buf, CMDSIZE, stdin))
      216:  115:    if(argv[*pos]!='\0')
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
        -:  116:    {
      180:  117:	*prio = *command = -1; *ratio =-1.0;
        -:  118:	//sscanf(buf, "%d", command);
      180:  119:        getAdata(argv,pos,value);
call    0 returned 100%
      180:  120:        *command=atoi(value);
call    0 returned 100%
      180:  121:	switch(*command)
branch  0 taken 16%
branch  1 taken 24%
branch  2 taken 9%
branch  3 taken 51%
        -:  122:	{
        -:  123:	  case NEW_JOB :
        -:  124:	    //sscanf(buf, "%*s%d", prio);
       28:  125:            getAdata(argv,pos,value);
call    0 returned 100%
       28:  126:            *prio=atoi(value);
call    0 returned 100%
       28:  127:	    break;
        -:  128:	  case UNBLOCK :
        -:  129:	    //sscanf(buf, "%*s%f", ratio);
       43:  130:            getAdata(argv,pos,value);
call    0 returned 100%
       43:  131:            *ratio=(float)(getOperand(value));
call    0 returned 100%
       43:  132:	    break;
        -:  133:	  case UPGRADE_PRIO :
       17:  134:            getAdata(argv,pos,value);
call    0 returned 100%
       17:  135:            *prio=atoi(value);
call    0 returned 100%
       17:  136:            getAdata(argv,pos,value);
call    0 returned 100%
       17:  137:            *ratio=(float)(getOperand(value));
call    0 returned 100%
        -:  138:	    //sscanf(buf, "%*s%d%f", prio, ratio);
        -:  139:	    break;
        -:  140:	}
        -:  141:	 /* Find end of  line of input if no EOF */
        -:  142:	//while(buf[strlen(buf)-1] != '\n' && fgets(buf, CMDSIZE, stdin));
      180:  143:        while(argv[*pos]!='\0' && argv[*pos]!='\n'){ (*pos)++;}
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
      180:  144:        if(argv[*pos]=='\n') (*pos)++;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      180:  145:	return(TRUE);
        -:  146:    }
       36:  147:    else return(FALSE);
        -:  148:}
        -:  149:
function exit_here called 0 returned 0% blocks executed 0%
    #####:  150:exit_here(status)
        -:  151:     int status;
        -:  152:{
    #####:  153:    exit(abs(status));
call    0 never executed
        -:  154:}
        -:  155:
        -:  156:
        -:  157:int 
function new_job called 249 returned 100% blocks executed 88%
      249:  158:new_job(prio) /* allocate new pid and process block. Stick at end */
        -:  159:     int prio;
        -:  160:{
      249:  161:    int pid, status = OK;
        -:  162:    struct process *new_process;
      249:  163:    pid = next_pid++;
      249:  164:    new_process = (struct process *) malloc(sizeof(struct process));
      249:  165:    if(!new_process) status = MALLOC_ERR;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  166:    else
        -:  167:    {
      249:  168:	new_process->pid = pid;
      249:  169:	new_process->priority = prio;
      249:  170:	new_process->next = (struct process *) 0;
      249:  171:	status = enqueue(prio, new_process);
call    0 returned 100%
      249:  172:	if(status)
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
        -:  173:	{
        4:  174:	    free(new_process); /* Return process block */
        -:  175:	}
        -:  176:    }
      249:  177:    if(status) next_pid--; /* Unsuccess. Restore pid */
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
      249:  178:    return(status);
        -:  179:}
        -:  180:
function upgrade_prio called 17 returned 100% blocks executed 100%
       17:  181:int upgrade_prio(prio, ratio) /* increment priority at ratio in queue */
        -:  182:     int prio;
        -:  183:     float ratio;
        -:  184:{
        -:  185:    int status;
        -:  186:    struct process * job;
        -:  187:    //if(prio < 1 || prio > MAXLOPRIO) return(BADPRIO); //fault
       17:  188:    if((status = get_process(prio, ratio, &job)) <= 0) return(status);
call    0 returned 100%
branch  1 taken 71% (fallthrough)
branch  2 taken 29%
        -:  189:    /* We found a job in that queue. Upgrade it */
        5:  190:    job->priority = prio + 1;
        5:  191:    return(enqueue(prio + 1, job));
call    0 returned 100%
        -:  192:}
        -:  193:
        -:  194:int
function block called 9 returned 100% blocks executed 83%
        9:  195:block() /* Put current job in blocked queue */
        -:  196:{
        -:  197:    struct process * job;
        9:  198:    job = get_current();
call    0 returned 100%
        9:  199:    if(job)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  200:    {
        9:  201:	current_job = (struct process *)0; /* remove it */
        9:  202:	return(enqueue(BLOCKPRIO, job)); /* put into blocked queue */
call    0 returned 100%
        -:  203:    }
    #####:  204:    return(OK);
        -:  205:}
        -:  206:
        -:  207:int
function unblock called 43 returned 100% blocks executed 100%
       43:  208:unblock(ratio) /* Restore job @ ratio in blocked queue to its queue */
        -:  209:     float ratio;
        -:  210:{
        -:  211:    int status;
        -:  212:    struct process * job;
       43:  213:    if((status = get_process(BLOCKPRIO, ratio, &job)) <= 0) return(status);
call    0 returned 100%
branch  1 taken 70% (fallthrough)
branch  2 taken 30%
        -:  214:    /* We found a blocked process. Put it where it belongs. */
       13:  215:    return(enqueue(job->priority, job));
call    0 returned 100%
        -:  216:}
        -:  217:
        -:  218:int
function quantum_expire called 65 returned 100% blocks executed 100%
       65:  219:quantum_expire() /* put current job at end of its queue */
        -:  220:{
        -:  221:    struct process * job;
       65:  222:    job = get_current();
call    0 returned 100%
       65:  223:    if(job)
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
        -:  224:    {
       51:  225:	current_job = (struct process *)0; /* remove it */
       51:  226:	return(enqueue(job->priority, job));
call    0 returned 100%
        -:  227:    }
       14:  228:    return(OK);
        -:  229:}
        -:  230:
        -:  231:int
function finish called 61 returned 100% blocks executed 100%
       61:  232:finish(char *r) /* Get current job, print it, and zap it. */
        -:  233:{
        -:  234:    struct process * job;
       61:  235:    char s[10]="";
       61:  236:    job = get_current();
call    0 returned 100%
       61:  237:    if(job)
branch  0 taken 84% (fallthrough)
branch  1 taken 16%
        -:  238:    {
       51:  239:	current_job = (struct process *)0;
       51:  240:	reschedule(0);
call    0 returned 100%
        -:  241:	//fprintf(stdout, " %d", job->pid);
       51:  242:        snprintf(s,10,"%d",job->pid);
       51:  243:        strcat(r," ");
       51:  244:        strcat(r,s);
       51:  245:	free(job);
       51:  246:	return(FALSE);
        -:  247:    }
       10:  248:    else return(TRUE);
        -:  249:}
        -:  250:
        -:  251:int
function flush called 9 returned 100% blocks executed 100%
       52:  252:flush(char *r) /* Get all jobs in priority queues & zap them */
        -:  253:{
       52:  254:    while(!finish(r));
call    0 returned 100%
branch  1 taken 83%
branch  2 taken 17% (fallthrough)
        -:  255:    //fprintf(stdout, "\n");
        -:  256:   // strcat(r,"\n");
        9:  257:    return(OK);
        -:  258:}
        -:  259:
        -:  260:struct process * 
function get_current called 509 returned 100% blocks executed 100%
      509:  261:get_current() /* If no current process, get it. Return it */
        -:  262:{
        -:  263:    int prio;
      509:  264:    if(!current_job)
branch  0 taken 36% (fallthrough)
branch  1 taken 64%
        -:  265:    {
      419:  266:	for(prio = MAXPRIO; prio > 0; prio--)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:  267:	{ /* find head of highest queue with a process */
      381:  268:	    if(get_process(prio, 0.0, &current_job) > 0) break;
call    0 returned 100%
branch  1 taken 38% (fallthrough)
branch  2 taken 62%
        -:  269:	}
        -:  270:    }
      509:  271:    return(current_job);
        -:  272:}
        -:  273:
        -:  274:int
function reschedule called 374 returned 100% blocks executed 100%
      374:  275:reschedule(prio) /* Put highest priority job into current_job */
        -:  276:     int prio;
        -:  277:{
      374:  278:    if(current_job && prio > current_job->priority)
branch  0 taken 59% (fallthrough)
branch  1 taken 41%
branch  2 taken 3% (fallthrough)
branch  3 taken 97%
        -:  279:    {
        6:  280:	put_end(current_job->priority, current_job);
call    0 returned 100%
        6:  281:	current_job = (struct process *)0;
        -:  282:    }
      374:  283:    get_current(); /* Reschedule */
call    0 returned 100%
      374:  284:    return(OK);
        -:  285:}
        -:  286:
function schedule called 180 returned 100% blocks executed 94%
      180:  287:int schedule(int command, int prio, float ratio, char *r)
        -:  288:{
      180:  289:    int status = OK;
      180:  290:    switch(command)
branch  0 taken 16%
branch  1 taken 36%
branch  2 taken 9%
branch  3 taken 5%
branch  4 taken 24%
branch  5 taken 5%
branch  6 taken 5%
branch  7 taken 0%
        -:  291:    {
        -:  292:      case NEW_JOB :
       28:  293:        status = new_job(prio);
call    0 returned 100%
       28:  294:	break;
        -:  295:      case QUANTUM_EXPIRE :
       65:  296:        status = quantum_expire();
call    0 returned 100%
       65:  297:	break;
        -:  298:      case UPGRADE_PRIO :
       17:  299:        status = upgrade_prio(prio, ratio);
call    0 returned 100%
       17:  300:	break;
        -:  301:      case BLOCK :
        9:  302:        status = block();
call    0 returned 100%
        9:  303:	break;
        -:  304:      case UNBLOCK :
       43:  305:        status = unblock(ratio);
call    0 returned 100%
       43:  306:	break;
        -:  307:      case FINISH :
        9:  308:        finish(r);
call    0 returned 100%
        -:  309:	//fprintf(stdout, "\n");
        -:  310:    //strcat(r,"\n");
        9:  311:	break;
        -:  312:      case FLUSH :
        9:  313:        status = flush(r);
call    0 returned 100%
        9:  314:	break;
        -:  315:      default:
    #####:  316:	status = NO_COMMAND;
        -:  317:    }
      180:  318:    return(status);
        -:  319:}
        -:  320:
        -:  321:
        -:  322:
        -:  323:
        -:  324:int 
function put_end called 333 returned 100% blocks executed 100%
      333:  325:put_end(prio, process) /* Put process at end of queue */
        -:  326:     int prio;
        -:  327:     struct process *process;
        -:  328:{
        -:  329:    struct process **next;
      333:  330:    if(prio > MAXPRIO || prio < 0) return(BADPRIO); /* Somebody goofed */
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  331:     /* find end of queue */
      329:  332:    for(next = &prio_queue[prio].head; *next; next = &(*next)->next);
branch  0 taken 68%
branch  1 taken 32% (fallthrough)
      329:  333:    *next = process;
      329:  334:    prio_queue[prio].length++;
      329:  335:    return(OK);
        -:  336:}
        -:  337:
        -:  338:int 
function get_process called 441 returned 100% blocks executed 100%
      441:  339:get_process(prio, ratio, job)
        -:  340:     int prio;
        -:  341:     float ratio;
        -:  342:     struct process ** job;
        -:  343:{
        -:  344:    int length, index;
        -:  345:    struct process **next;
      441:  346:    if(prio > MAXPRIO || prio < 0) return(BADPRIO); /* Somebody goofed */
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
      439:  347:    if(ratio < 0.0 || ratio > 1.0) return(BADRATIO); /* Somebody else goofed */
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 2% (fallthrough)
branch  3 taken 98%
      432:  348:    length = prio_queue[prio].length;
      432:  349:    index = ratio * length;
      432:  350:    index = index >= length ? length -1 : index; /* If ratio == 1.0 */
branch  0 taken 63% (fallthrough)
branch  1 taken 37%
      433:  351:    for(next = &prio_queue[prio].head; index && *next; index--)
branch  0 taken 63% (fallthrough)
branch  1 taken 37%
branch  2 taken 1%
branch  3 taken 99% (fallthrough)
        1:  352:        next = &(*next)->next; /* Count up to it */
      432:  353:    *job = *next;
      432:  354:    if(*job)
branch  0 taken 38% (fallthrough)
branch  1 taken 63%
        -:  355:    {
      162:  356:	*next = (*next)->next; /* Mend the chain */
      162:  357:	(*job)->next = (struct process *) 0; /* break this link */
      162:  358:	prio_queue[prio].length--;
      162:  359:	return(TRUE);
        -:  360:    }
      270:  361:    else return(FALSE);
        -:  362:}
