        -:    0:Source:replace12.c
        -:    0:Graph:replace12.gcno
        -:    0:Data:replace12.gcda
        -:    0:Runs:50
        -:    0:Programs:1
        -:    1:/*  -*- Last-Edit:  Mon Dec  7 10:31:51 1992 by Tarak S. Goradia; -*- */
        -:    2:
        -:    3:extern void	exit();
        -:    4:# include <stdio.h>
        -:    5:
        -:    6:void	Caseerror();
        -:    7:
        -:    8:typedef char	bool;
        -:    9:# define false 0
        -:   10:# define true  1
        -:   11:# define NULL 0
        -:   12:
        -:   13:# define MAXSTR 100
        -:   14://# define MAXPAT 50 //fault MAXSTR
        -:   15:
        -:   16:# define ENDSTR  '\0'
        -:   17:# define ESCAPE  '@'
        -:   18:# define CLOSURE '*'
        -:   19:# define BOL     '%'
        -:   20:# define EOL     '$'
        -:   21:# define ANY     '?'
        -:   22:# define CCL     '['
        -:   23:# define CCLEND  ']'
        -:   24:# define NEGATE  '^'
        -:   25:# define NCCL    '!'
        -:   26:# define LITCHAR 'c'
        -:   27:# define DITTO   -1
        -:   28:# define DASH    '-'
        -:   29:
        -:   30:# define TAB     9
        -:   31:# define NEWLINE 10
        -:   32:
        -:   33:# define CLOSIZE 1
        -:   34:
        -:   35:typedef char	character;
        -:   36:typedef char string[MAXSTR];
        -:   37:
        -:   38:
function MAXPAT called 0 returned 0% blocks executed 0%
    #####:   39:int MAXPAT()
        -:   40:{
    #####:   41:  return 50;
        -:   42:}
        -:   43:
        -:   44:int
function addstr called 300 returned 100% blocks executed 75%
      300:   45:addstr(c, outset, j, maxset)
        -:   46:char	c;
        -:   47:char	*outset;
        -:   48:int	*j;
        -:   49:int	maxset;
        -:   50:{
        -:   51:    bool	result;
      300:   52:    if (*j >= maxset)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   53:	result = false;
        -:   54:    else {
      300:   55:	outset[*j] = c;
      300:   56:	*j = *j + 1;
      300:   57:	result = true;
        -:   58:    }
      300:   59:    return result;
        -:   60:}
        -:   61:
        -:   62:char
function esc called 38 returned 100% blocks executed 100%
       38:   63:esc(s, i)
        -:   64:char 	*s;
        -:   65:int	*i;
        -:   66:{
        -:   67:    char	result;
       38:   68:    if (s[*i] != ESCAPE)
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
       23:   69:	result = s[*i];
        -:   70:    else
       15:   71:	if (s[*i + 1] == ENDSTR)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
        4:   72:	    result = ESCAPE;
        -:   73:	else 
        -:   74:	{
       11:   75:	    *i = *i + 1;
       11:   76:	    if (s[*i] == 'n')
branch  0 taken 36% (fallthrough)
branch  1 taken 64%
        4:   77:		result = NEWLINE;
        -:   78:	    else
        7:   79:		if (s[*i] == 't')
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
        4:   80:		    result = TAB;
        -:   81:		else
        3:   82:		    result = s[*i];
        -:   83:	}
       38:   84:    return result;
        -:   85:}
        -:   86:
        -:   87:char * change();
        -:   88:
        -:   89: void
function dodash called 20 returned 100% blocks executed 77%
       20:   90:dodash(delim, src, i, dest, j, maxset)
        -:   91:char	delim;
        -:   92:char	*src;
        -:   93:int	*i;
        -:   94:char	*dest;
        -:   95:int	*j;
        -:   96:int	maxset;
        -:   97:{
        -:   98:    int	k;
        -:   99:    bool	junk;
        -:  100:    char	escjunk;
        -:  101:
       77:  102:    while ((src[*i] != delim) && (src[*i] != ENDSTR)) 
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
branch  2 taken 86%
branch  3 taken 14% (fallthrough)
        -:  103:    {
       37:  104:	if (src[*i - 1] == ESCAPE) {
branch  0 taken 22% (fallthrough)
branch  1 taken 78%
        8:  105:	    escjunk = esc(src, i);
call    0 returned 100%
        8:  106:	    junk = addstr(escjunk, dest, j, maxset);
call    0 returned 100%
        -:  107:	} else	
       29:  108:	    if (src[*i] != DASH)
branch  0 taken 72% (fallthrough)
branch  1 taken 28%
       21:  109:		junk = addstr(src[*i], dest, j, maxset);
call    0 returned 100%
       12:  110:	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
        4:  111:		junk = addstr(DASH, dest, j, maxset);
call    0 returned 100%
        4:  112:	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1])) 
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
    #####:  113:		&& (src[*i - 1] <= src[*i + 1]))
        -:  114:		{
    #####:  115:		    for (k = src[*i-1]+1; k<=src[*i+1]; k++) 
branch  0 never executed
branch  1 never executed
        -:  116:		    {
    #####:  117:			junk = addstr(k, dest, j, maxset);
call    0 never executed
        -:  118:		    }	
    #####:  119:		    *i = *i + 1;	
        -:  120:		} 
        -:  121:	    else	
        4:  122:		junk = addstr(DASH, dest, j, maxset);
call    0 returned 100%
       37:  123:	(*i) = (*i) + 1;
        -:  124:    }
       20:  125:}
        -:  126:
        -:  127:bool
function getccl called 20 returned 100% blocks executed 100%
       20:  128:getccl(arg, i, pat, j)
        -:  129:char	*arg;
        -:  130:int	*i;
        -:  131:char	*pat;
        -:  132:int	*j;
        -:  133:{
        -:  134:    int	jstart;
        -:  135:    bool	junk;
        -:  136:
       20:  137:    *i = *i + 1;
       20:  138:    if (arg[*i] == NEGATE) {
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
        8:  139:	junk = addstr(NCCL, pat, j, MAXPAT);
call    0 returned 100%
        8:  140:	*i = *i + 1;
        -:  141:    } else
       12:  142:	junk = addstr(CCL, pat, j, MAXPAT);
call    0 returned 100%
       20:  143:    jstart = *j;
       20:  144:    junk = addstr(0, pat, j, MAXPAT);
call    0 returned 100%
       20:  145:    dodash(CCLEND, arg, i, pat, j, MAXPAT);
call    0 returned 100%
       20:  146:    pat[jstart] = *j - jstart - 1;
       20:  147:    return (arg[*i] == CCLEND);
        -:  148:}
        -:  149:
        -:  150: void
function stclose called 5 returned 100% blocks executed 100%
        5:  151:stclose(pat, j, lastj)
        -:  152:char	*pat;
        -:  153:int	*j;
        -:  154:int	lastj;
        -:  155:{
        -:  156:    int	jt;
        -:  157:    int	jp;
        -:  158:    bool	junk;
        -:  159:
        -:  160:
       12:  161:    for (jp = *j - 1; jp >= lastj ; jp--) 
branch  0 taken 58%
branch  1 taken 42% (fallthrough)
        -:  162:    {
        7:  163:	jt = jp + CLOSIZE;
        7:  164:	junk = addstr(pat[jp], pat, &jt, MAXPAT);
call    0 returned 100%
        -:  165:    }
        5:  166:    *j = *j + CLOSIZE;
        5:  167:    pat[lastj] = CLOSURE;
        5:  168:}
        -:  169:
function in_set_2 called 6 returned 100% blocks executed 100%
        6:  170:bool in_set_2(c)
        -:  171:char c;
        -:  172:{
        6:  173:  return (c == BOL || c == EOL || c == CLOSURE);
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -:  174:}      
        -:  175:
function in_pat_set called 255 returned 100% blocks executed 90%
      255:  176:bool in_pat_set(c)
        -:  177:char c;
        -:  178:{
      255:  179:  return (   c == LITCHAR || c == BOL  || c == EOL || c == ANY 
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
branch  2 taken 87% (fallthrough)
branch  3 taken 13%
branch  4 taken 97% (fallthrough)
branch  5 taken 3%
branch  6 taken 51% (fallthrough)
branch  7 taken 49%
branch  8 taken 46% (fallthrough)
branch  9 taken 54%
branch 10 taken 11% (fallthrough)
branch 11 taken 89%
branch 12 taken 100% (fallthrough)
branch 13 taken 0%
        -:  180:          || c == CCL     || c == NCCL || c == CLOSURE);
        -:  181:}      
        -:  182:
        -:  183:int
function makepat called 50 returned 100% blocks executed 97%
       50:  184:makepat(arg, start, delim, pat)
        -:  185:char	*arg;
        -:  186:int	start;
        -:  187:char	delim;
        -:  188:char	*pat;
        -:  189:{
        -:  190:    int	result;
        -:  191:    int	i, j, lastj, lj;
        -:  192:    bool	done, junk;
        -:  193:    bool	getres;
        -:  194:    char	escjunk;
        -:  195:
       50:  196:    j = 0;
       50:  197:    i = start;
       50:  198:    lastj = 0;
       50:  199:    done = false;
      167:  200:    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
branch  2 taken 61% (fallthrough)
branch  3 taken 39%
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
       67:  201:	lj = j;
       67:  202:	if ((arg[i] == ANY))
branch  0 taken 30% (fallthrough)
branch  1 taken 70%
       20:  203:	    junk = addstr(ANY, pat, &j, MAXPAT);
call    0 returned 100%
       52:  204:	else if ((arg[i] == BOL) && (i == start))
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        5:  205:	    junk = addstr(BOL, pat, &j, MAXPAT);
call    0 returned 100%
       44:  206:	else if ((arg[i] == EOL) && (arg[i+1] == delim))
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
branch  2 taken 40% (fallthrough)
branch  3 taken 60%
        2:  207:	    junk = addstr(EOL, pat, &j, MAXPAT);
call    0 returned 100%
       40:  208:	else if ((arg[i] == CCL)) 
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  209:	{
       20:  210:	    getres = getccl(arg, &i, pat, &j);
call    0 returned 100%
       20:  211:	    done = (bool)(getres == false);
        -:  212:	} 
       26:  213:	else if ((arg[i] == CLOSURE) && (i > start)) 
branch  0 taken 30% (fallthrough)
branch  1 taken 70%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  214:	{
        6:  215:	    lj = lastj;
        6:  216:	    if (in_set_2(pat[lj]))
call    0 returned 100%
branch  1 taken 17% (fallthrough)
branch  2 taken 83%
        1:  217:		done = true;
        -:  218:	    else
        5:  219:		stclose(pat, &j, lastj);
call    0 returned 100%
        -:  220:	} 
        -:  221:	else 
        -:  222:	{
       14:  223:	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
call    0 returned 100%
       14:  224:	    escjunk = esc(arg, &i);
call    0 returned 100%
       14:  225:	    junk = addstr(escjunk, pat, &j, MAXPAT);
call    0 returned 100%
        -:  226:	}
       67:  227:	lastj = lj;
       67:  228:	if ((!done))
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
       60:  229:	    i = i + 1;
        -:  230:    }	
       50:  231:    junk = addstr(ENDSTR, pat, &j, MAXPAT);
call    0 returned 100%
       57:  232:    if ((done) || (arg[i] != delim))
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        7:  233:	result = 0;
        -:  234:    else
       43:  235:	if ((!junk))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  236:	    result = 0;
        -:  237:	else
       43:  238:	    result = i;
       50:  239:    return result;
        -:  240:}
        -:  241:
        -:  242:int
function getpat called 50 returned 100% blocks executed 100%
       50:  243:getpat(arg, pat)
        -:  244:char*	arg;
        -:  245:char*	pat;
        -:  246:{
        -:  247:    int	makeres;
        -:  248:
       50:  249:    makeres = makepat(arg, 0, ENDSTR, pat);
call    0 returned 100%
       50:  250:    return (makeres > 0);
        -:  251:}
        -:  252:
        -:  253:int
function makesub called 50 returned 100% blocks executed 88%
       50:  254:makesub(arg, from, delim, sub)
        -:  255:	char*	arg;
        -:  256:	int	from;
        -:  257:	character	delim;
        -:  258:	char*	sub;
        -:  259:{
        -:  260:    int  result;
        -:  261:    int	i, j;
        -:  262:    bool	junk;
        -:  263:    character	escjunk;
        -:  264:
       50:  265:    j = 0;
       50:  266:    i = from;
      161:  267:    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
branch  0 taken 55% (fallthrough)
branch  1 taken 45%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
       61:  268:	if ((arg[i] == (unsigned)('&')))
branch  0 taken 74% (fallthrough)
branch  1 taken 26%
       45:  269:	    junk = addstr(DITTO, sub, &j, MAXPAT);
call    0 returned 100%
        -:  270:	else {
       16:  271:	    escjunk = esc(arg, &i);
call    0 returned 100%
       16:  272:	    junk = addstr(escjunk, sub, &j, MAXPAT);
call    0 returned 100%
        -:  273:	}
       61:  274:	i = i + 1;
        -:  275:    }
       50:  276:    if (arg[i] != delim)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  277:	result = 0;
        -:  278:    else {
       50:  279:	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
call    0 returned 100%
       50:  280:	if ((!junk))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  281:	    result = 0;
        -:  282:	else
       50:  283:	    result = i;
        -:  284:    }	
       50:  285:    return result;
        -:  286:}
        -:  287:
        -:  288:bool
function getsub called 50 returned 100% blocks executed 100%
       50:  289:getsub(arg, sub)
        -:  290:	char*	arg;
        -:  291:	char*	sub;
        -:  292:{
        -:  293:    int	makeres;
        -:  294:
       50:  295:    makeres = makesub(arg, 0, ENDSTR, sub);
call    0 returned 100%
       50:  296:    return (makeres > 0);
        -:  297:}
        -:  298:
        -:  299:char * subline();
        -:  300:
        -:  301: bool
function locate called 60 returned 100% blocks executed 100%
       60:  302:locate(c, pat, offset)
        -:  303:	character	c;
        -:  304:	char *	pat;
        -:  305:	int	offset;
        -:  306:{
        -:  307:    int	i;
        -:  308:    bool flag;
        -:  309:
       60:  310:    flag = false;
       60:  311:    i = offset + pat[offset];
      220:  312:    while ((i > offset))
branch  0 taken 63%
branch  1 taken 38% (fallthrough)
        -:  313:    {
      100:  314:	if (c == pat[i]) {
branch  0 taken 15% (fallthrough)
branch  1 taken 85%
       15:  315:	    flag = true;
       15:  316:	    i = offset;
        -:  317:	} else
       85:  318:	    i = i - 1;
        -:  319:    }
       60:  320:    return flag;
        -:  321:}
        -:  322:
        -:  323:bool
function omatch called 160 returned 100% blocks executed 88%
      160:  324:omatch(lin, i, pat, j)
        -:  325:	char*	lin;
        -:  326:	int	*i;
        -:  327:	char*	pat;
        -:  328:	int	j;
        -:  329:{
        -:  330:    char	advance;
        -:  331:    bool result;
        -:  332:    
      160:  333:    advance = -1;
      160:  334:    if ((lin[*i] == ENDSTR))
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        2:  335:	result = false;
        -:  336:    else 
        -:  337:    {
      158:  338:	if (!in_pat_set(pat[j]))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  339:	{
    #####:  340:	    (void)fprintf(stdout, "in omatch: can't happen\n");
call    0 never executed
    #####:  341:	    abort();	
call    0 never executed
        -:  342:	} else
        -:  343:	{
      158:  344:	     switch (pat[j]) 
branch  0 taken 12%
branch  1 taken 15%
branch  2 taken 31%
branch  3 taken 4%
branch  4 taken 25%
branch  5 taken 13%
branch  6 taken 0%
        -:  345:	     {			
        -:  346:	     case LITCHAR:
       19:  347:		 if (lin[*i] == pat[j + 1])
branch  0 taken 58% (fallthrough)
branch  1 taken 42%
       11:  348:		     advance = 1;
       19:  349:		 break ;	
        -:  350:	     case BOL:
       24:  351:		 if (*i == 0)
branch  0 taken 21% (fallthrough)
branch  1 taken 79%
        5:  352:		     advance = 0;
       24:  353:		 break ;
        -:  354:	     case ANY:
       49:  355:		 if (lin[*i] != NEWLINE)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       49:  356:		     advance = 1;
       49:  357:		 break ;
        -:  358:	     case EOL:
        6:  359:		 if (lin[*i] == NEWLINE)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  360:		     advance = 0;
        6:  361:		 break ;
        -:  362:	     case CCL:
       39:  363:		 if (locate(lin[*i], pat, j + 1))
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
       13:  364:		     advance = 1;	
       39:  365:		 break ;
        -:  366:	     case NCCL:
       21:  367:		 if ((lin[*i] != NEWLINE) && (!locate(lin[*i], pat, j+1)))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 90% (fallthrough)
branch  4 taken 10%
       19:  368:		     advance = 1;	
       21:  369:		 break ;
        -:  370:	     default:
    #####:  371:		 Caseerror(pat[j]);
call    0 never executed
        -:  372:	     };
        -:  373:	 }	
        -:  374:    }
      160:  375:    if ((advance >= 0)) 
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
        -:  376:    {
       97:  377:	*i = *i + advance;
       97:  378:	result = true;
        -:  379:    } else
       63:  380:	result = false;
      160:  381:    return result;
        -:  382:}
        -:  383:
        -:  384:
function patsize called 97 returned 100% blocks executed 73%
       97:  385:patsize(pat, n)
        -:  386:	char*	pat;
        -:  387:	int	n;
        -:  388:{
        -:  389:    int size;
       97:  390:    if (!in_pat_set(pat[n])) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  391:	(void)fprintf(stdout, "in patsize: can't happen\n");
call    0 never executed
    #####:  392:	abort();
call    0 never executed
        -:  393:    } else
       97:  394:	switch (pat[n]) 
branch  0 taken 11%
branch  1 taken 52%
branch  2 taken 32%
branch  3 taken 5%
branch  4 taken 0%
        -:  395:	{
       11:  396:	case LITCHAR: size = 2; break;
        -:  397:	    
        -:  398:	case BOL:  case EOL:  case ANY:
       50:  399:	    size = 1;
       50:  400:	    break;
        -:  401:	case CCL:  case NCCL:
       31:  402:	    size = pat[n + 1] + 2;
       31:  403:	    break ;
        -:  404:	case CLOSURE:
        5:  405:	    size = CLOSIZE;
        5:  406:	    break ;
        -:  407:	default:
    #####:  408:	    Caseerror(pat[n]);
call    0 never executed
        -:  409:	}
       97:  410:    return size;
        -:  411:}
        -:  412:
        -:  413:int
function amatch called 145 returned 100% blocks executed 96%
      145:  414:amatch(lin, offset, pat, j)
        -:  415:	char*	lin;
        -:  416:	int	offset;
        -:  417:	char*	pat;
        -:  418:	int	j;
        -:  419:{
        -:  420:    int	i, k;
        -:  421:    bool	result, done;
        -:  422:
      145:  423:    done = false;
      444:  424:    while ((!done) && (pat[j] != ENDSTR))
branch  0 taken 77% (fallthrough)
branch  1 taken 23%
branch  2 taken 67%
branch  3 taken 33% (fallthrough)
      154:  425:	if ((pat[j] == CLOSURE)) {
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        5:  426:	    j = j + patsize(pat, j);
call    0 returned 100%
        5:  427:	    i = offset;
       21:  428:	    while ((!done) && (lin[i] != ENDSTR)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 69%
branch  3 taken 31% (fallthrough)
       11:  429:		result = omatch(lin, &i, pat, j);
call    0 returned 100%
       11:  430:		if (!result)	
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  431:		    done = true;
        -:  432:	    }
        5:  433:	    done = false;
       16:  434:	    while ((!done) && (i >= offset)) {
branch  0 taken 55% (fallthrough)
branch  1 taken 45%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
        6:  435:		k = amatch(lin, i, pat, j + patsize(pat, j));
call    0 returned 100%
call    1 returned 100%
        6:  436:		if ((k >= 0))
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
        5:  437:		    done = true;
        -:  438:		else
        1:  439:		    i = i - 1;
        -:  440:	    }
        5:  441:	    offset = k;
        5:  442:	    done = true;
        -:  443:	} else {
      149:  444:	    result = omatch(lin, &offset, pat, j);
call    0 returned 100%
      149:  445:	    if ((!result)) {	
branch  0 taken 42% (fallthrough)
branch  1 taken 58%
       63:  446:		offset = -1;
       63:  447:		done = true;
        -:  448:	    } else
       86:  449:		j = j + patsize(pat, j);
call    0 returned 100%
        -:  450:	}
      145:  451:     return offset;
        -:  452:}
        -:  453:
        -:  454:void
function putsub called 77 returned 100% blocks executed 100%
       77:  455:putsub(lin, s1, s2, sub,output,OL)
        -:  456:  char * lin;
        -:  457:  int	s1, s2;
        -:  458:  char * sub;
        -:  459:  char * output;
        -:  460:  int *OL;
        -:  461:{
        -:  462:    int	i;
        -:  463:    int		j;
        -:  464:
       77:  465:    i = 0;
      260:  466:    while ((sub[i] != ENDSTR)) {
branch  0 taken 58%
branch  1 taken 42% (fallthrough)
      106:  467:	if ((sub[i] == DITTO))
branch  0 taken 63% (fallthrough)
branch  1 taken 37%
      147:  468:	    for (j = s1; j < s2; j++) 
branch  0 taken 54%
branch  1 taken 46% (fallthrough)
        -:  469:	    {
        -:  470:		//fputc(lin[j],stdout);
       80:  471:                output[*OL]=lin[j];(*OL)++;
        -:  472:	    }	
        -:  473:	else	
        -:  474:	{
        -:  475:	    //fputc(sub[i],stdout);
       39:  476:            output[*OL]=sub[i];(*OL)++;
        -:  477:         }
      106:  478:	i = i + 1;
        -:  479:    }
       77:  480:}
        -:  481:
        -:  482:char *
function subline called 50 returned 100% blocks executed 100%
       50:  483:subline(lin, pat, sub)
        -:  484: char	*lin;
        -:  485: char   *pat;
        -:  486: char   *sub;
        -:  487:{	
        -:  488:	int	i, lastm, m;
        -:  489:        static char O[1000]="";
       50:  490:        int OL=0;
       50:  491:	lastm = -1;
       50:  492:	i = 0;
      239:  493:	while ((lin[i] != ENDSTR)) 
branch  0 taken 74%
branch  1 taken 26% (fallthrough)
        -:  494:	{
      139:  495:	    m = amatch(lin, i, pat, 0);
call    0 returned 100%
      139:  496:	    if ((m >= 0) && (lastm != m)) {
branch  0 taken 55% (fallthrough)
branch  1 taken 45%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       77:  497:		putsub(lin, i, m, sub,O,&OL);
call    0 returned 100%
       77:  498:		lastm = m;
        -:  499:	    }
      206:  500:	    if ((m == -1) || (m == i)) {
branch  0 taken 55% (fallthrough)
branch  1 taken 45%
branch  2 taken 6% (fallthrough)
branch  3 taken 94%
        -:  501:		//fputc(lin[i],stdout);
       67:  502:                O[OL]=lin[i];OL++;
       67:  503:		i = i + 1;
        -:  504:	    } else
       72:  505:		i = m;
        -:  506:	}
       50:  507:        O[OL]='\0';
       50:  508:       return O;
        -:  509:}
        -:  510:
        -:  511: char *
function change called 50 returned 100% blocks executed 100%
       50:  512:change(pat, sub,line)
        -:  513:char *pat, *sub, *line;
        -:  514:{
       50:  515:  return subline(line, pat, sub);
call    0 returned 100%
        -:  516:}
function mainQ called 50 returned 100% blocks executed 100%
       50:  517:char *mainQ(char *argv1, char *argv2, char *argv3)
        -:  518:{
        -:  519:   string pat, sub;
        -:  520:   bool result;
       50:  521:   result = getpat(argv1, pat);
call    0 returned 100%
       50:  522:   result = getsub(argv2, sub);
call    0 returned 100%
       50:  523:   return change(pat,sub,argv3);
call    0 returned 100%
        -:  524:}
function main called 50 returned 100% blocks executed 100%
       50:  525:int main(int argc, char*argv[])
        -:  526:{
       50:  527:   fprintf(stdout,"%s\n",mainQ(argv[1],argv[2],argv[3]));
call    0 returned 100%
call    1 returned 100%
       50:  528:   return 0;
        -:  529:}
        -:  530:
        -:  531:void
function Caseerror called 0 returned 0% blocks executed 0%
    #####:  532:Caseerror(n)
        -:  533:	int	n;
        -:  534:{
    #####:  535:	(void)fprintf(stdout, "Missing case limb: line %d\n", n);
call    0 never executed
    #####:  536:	exit(4);
call    0 never executed
        -:  537:}
